<!DOCTYPE html>
<head>
<style>

body {background-color: #639492;}	

#uiWindow {
  position: absolute;
  top: 20px;
  left: 20px;
  width: 220px;
  background: rgba(20,20,30,0.95);
  color: #eee;
  border-radius: 10px;
  font-family: sans-serif;
  font-size: 14px;
  z-index: 10;
  user-select: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}

#uiHeader {
  padding: 8px 10px;
  cursor: grab;
  font-weight: bold;
  background: rgba(40,40,50,0.9);
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
}

#uiContent {
  padding: 10px;
}

#uiWindow button {
  background: #3b82f6;
  color: white;
  border: none;
  padding: 6px 10px;
  margin: 4px 0;
  border-radius: 6px;
  cursor: pointer;
  width: 100%;
}

#uiWindow button:hover {
  background: #2563eb;
}
</style>
</head>

<html>
<body style="margin:0;overflow:hidden;">
<canvas id="mapCanvas"></canvas>

<div id="uiWindow">
  <div id="uiHeader">Controls</div>
  <div id="uiContent">
    <button id="zoomIn">Zoom In</button>
    <button id="zoomOut">Zoom Out</button>
    <button id="resetView">Reset View</button>
    <hr>
    <label>Grid Size: <input type="number" id="gridSizeInput" value="50"></label>
  </div>
</div>


<script>
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

const gridSize = 1; // grid cell size in map pixels (before scaling)
const gridColor = 'rgba(255,255,255,0.25)'; // semi-transparent white
const gridZoomThreshold = 6; // show grid only when zoom > 1.5x

const uiWindow = document.getElementById('uiWindow');
const uiHeader = document.getElementById('uiHeader');

let zoom = 1;
let minZoom = 1;
let panX = 0;
let panY = 0;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;

// UI window variables
let isDraggingUI = false;
let UIdragStartX = 0, UIdragStartY = 0;
let UIwindowStartX = 0, UIwindowStartY = 0;


uiHeader.addEventListener('mousedown', e => {
  isDraggingUI = true;
  UIdragStartX = e.clientX;
  UIdragStartY = e.clientY;
  const rect = uiWindow.getBoundingClientRect();
  UIwindowStartX = rect.left;
  UIwindowStartY = rect.top;
});

document.addEventListener('mousemove', e => {
  if (!isDraggingUI) return;
  const dx = e.clientX - UIdragStartX;
  const dy = e.clientY - UIdragStartY;
  uiWindow.style.left = UIwindowStartX + dx + 'px';
  uiWindow.style.top = UIwindowStartY + dy + 'px';
});

document.addEventListener('mouseup', () => isDraggingUI = false);


const bg = new Image();
bg.src = 'images/World_map.svg'; // local copy
bg.onload = () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  zoom = Math.min(canvas.width / bg.naturalWidth, canvas.height / bg.naturalHeight);
  minZoom = zoom;
  panX = (canvas.width - bg.naturalWidth * zoom) / 2;
  panY = (canvas.height - bg.naturalHeight * zoom) / 2;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoom, zoom);
  ctx.drawImage(bg,0,0);
  ctx.restore();
};

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  zoom = Math.min(canvas.width / bg.naturalWidth, canvas.height / bg.naturalHeight);
  panX = (canvas.width - bg.naturalWidth * zoom) / 2;
  panY = (canvas.height - bg.naturalHeight * zoom) / 2;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoom, zoom);
  ctx.drawImage(bg,0,0);
  ctx.restore();
}


function drawGrid() {

  // only draw grid if zoomed in past threshold
  if (zoom <= gridZoomThreshold) return;

  const mapWidth = bg.naturalWidth;
  const mapHeight = bg.naturalHeight;

  ctx.save();
  ctx.translate(panX, panY);
  ctx.scale(zoom, zoom);
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1 / zoom; // keep lines thin regardless of zoom

  // Vertical lines
  for (let x = 0; x <= mapWidth; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, mapHeight);
    ctx.stroke();
  }

  // Horizontal lines
  for (let y = 0; y <= mapHeight; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(mapWidth, y);
    ctx.stroke();
  }

  ctx.restore();
}


function clampPan() {
  const mapWidth = bg.naturalWidth * zoom;
  const mapHeight = bg.naturalHeight * zoom;

  // If map is smaller than canvas, center it
  if (mapWidth < canvas.width) {
    panX = (canvas.width - mapWidth) / 2;
  } else {
    // Prevent dragging past left/right edges
    panX = Math.min(0, Math.max(canvas.width - mapWidth, panX));
  }

  if (mapHeight < canvas.height) {
    panY = (canvas.height - mapHeight) / 2;
  } else {
    // Prevent dragging past top/bottom edges
    panY = Math.min(0, Math.max(canvas.height - mapHeight, panY));
  }
}


function drawMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
	// draw map
      ctx.save();
      ctx.translate(panX, panY);
      ctx.scale(zoom, zoom);
      ctx.drawImage(bg, 0, 0);
      ctx.restore();

	// draw grid on top
	drawGrid();
    }

    // Mouse drag for panning
    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStartX = e.clientX - panX;
      dragStartY = e.clientY - panY;
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    canvas.addEventListener('mousemove', e => {
      if (!isDragging) return;
      panX = e.clientX - dragStartX;
      panY = e.clientY - dragStartY;
      clampPan();
      drawMap();
    });


canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const mouseX = e.clientX;
  const mouseY = e.clientY;

  const delta = e.deltaY < 0 ? 1.1 : 0.9;
  let newZoom = zoom * delta;

  // clamp zoom: never smaller than minZoom
  if (newZoom < minZoom) newZoom = minZoom;

  const prevZoom = zoom;
  zoom = newZoom;

  panX = mouseX - ((mouseX - panX) / prevZoom) * zoom;
  panY = mouseY - ((mouseY - panY) / prevZoom) * zoom;

  clampPan();
  drawMap();
});


window.addEventListener('resize', resizeCanvas);


</script>
</body>
</html>
